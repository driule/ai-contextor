/**
 * Task Documentation Integrator
 * 
 * Integrates task documentation into main documentation
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const { getFileModTime } = require('./parser');
const { getCurrentGitHash } = require('./git');

class TaskIntegrator {
  constructor(projectRoot, config = {}) {
    this.projectRoot = projectRoot;
    this.config = config;
    this.devDir = path.join(projectRoot, '.ai', 'dev');
    this.docsDir = path.join(projectRoot, config.docsDir || '.ai');
  }

  /**
   * Integrate task documentation into main docs
   */
  async integrate(tasks, options = {}) {
    if (!tasks || tasks.length === 0) {
      return { updated: [], created: [], drafts: [] };
    }

    const taskDirs = tasks.map(task => {
      const taskName = task.startsWith('task-') ? task : `task-${task}`;
      return path.join(this.devDir, taskName);
    });

    const updated = [];
    const created = [];
    const drafts = [];

    for (const taskDir of taskDirs) {
      if (!fs.existsSync(taskDir)) {
        console.warn(`âš ï¸  Task directory not found: ${taskDir}`);
        continue;
      }

      const taskInfo = this.readTaskInfo(taskDir);
      if (!taskInfo) {
        continue;
      }

      // Find changed files related to this task
      const changedFiles = this.getChangedFiles(taskDir);
      
      if (options.draftOnly || options.draft) {
        // Generate draft documentation in task folder
        const draftResult = this.generateDrafts(taskInfo, changedFiles, taskDir);
        drafts.push(...draftResult);
      } else {
        // Update or create documentation based on task
        const result = await this.updateDocumentation(taskInfo, changedFiles);
        updated.push(...result.updated);
        created.push(...result.created);
      }
    }

    return { updated, created, drafts };
  }

  /**
   * Generate draft documentation files in task directory
   */
  generateDrafts(taskInfo, changedFiles, taskDir) {
    const drafts = [];
    const docTargets = this.determineDocTargets(taskInfo, changedFiles);
    const date = new Date().toISOString().split('T')[0];

    for (const target of docTargets) {
      const draftPath = path.join(taskDir, `doc-integration-${target.type}.md`);
      const draftContent = this.generateDraftContent(target, taskInfo, changedFiles, date);
      
      fs.writeFileSync(draftPath, draftContent, 'utf8');
      drafts.push(draftPath);
    }

    // Generate integration instructions
    const instructionsPath = path.join(taskDir, 'DOC-INTEGRATION.md');
    const instructionsContent = this.generateIntegrationInstructions(taskInfo, docTargets, date);
    fs.writeFileSync(instructionsPath, instructionsContent, 'utf8');
    drafts.push(instructionsPath);

    return drafts;
  }

  /**
   * Generate draft content for documentation integration
   */
  generateDraftContent(target, taskInfo, changedFiles, date) {
    const taskSummary = this.extractTaskSummary(taskInfo);
    const changedFilesList = changedFiles.length > 0
      ? changedFiles.map(f => `- \`${path.relative(this.projectRoot, f.file)}\` (${f.status})`).join('\n')
      : '- No specific files detected';

    return `# Draft: ${this.getDocTitle(target.type)}

**Generated**: ${date}
**Task**: ${taskInfo.description}
**Status**: ${taskInfo.status}

> âš ï¸ This is a DRAFT for documentation integration.
> Review and improve this content before integrating into main documentation.

## Task Summary

${taskSummary}

## Changed Files

${changedFilesList}

## Proposed Documentation Content

### Overview Section

${this.getDocOverview(target.type)}

### Task Implementation Details

Based on task requirements and implementation:

${this.extractDetailedContent(taskInfo)}

## Integration Instructions

1. Review this draft content
2. Improve and refine the documentation
3. Add context from code changes
4. Ensure consistency with existing documentation
5. Use \`contextor task-${path.basename(taskInfo.dir).replace('task-', '')} --integrate\` to integrate

## Notes

- This draft is based on task documentation and changed files
- Review and enhance before integration
- Consider adding code examples if relevant
- Link to related documentation sections

---
*Generated by AI Contextor - Task Integration Draft*
`;
  }

  /**
   * Generate integration instructions file
   */
  generateIntegrationInstructions(taskInfo, docTargets, date) {
    const taskNumber = path.basename(taskInfo.dir).replace('task-', '');
    const targetsList = docTargets.map(t => `- \`.ai/${t.path}\` (${t.type})`).join('\n');

    return `# Documentation Integration Instructions

**Task**: ${taskInfo.description}
**Generated**: ${date}

## ðŸ“‹ Overview

This task requires documentation updates. Draft files have been generated for your review.

## ðŸ“„ Draft Files Generated

${docTargets.map(t => `- \`doc-integration-${t.type}.md\` â†’ Target: \`.ai/${t.path}\``).join('\n')}

## ðŸ¤– For AI Assistant

### Your Task

Review and improve the draft documentation files in this directory:

${docTargets.map(t => `- \`doc-integration-${t.type}.md\` - Draft for \`.ai/${t.path}\``).join('\n')}

### Steps

1. **Read the drafts**: Review each \`doc-integration-*.md\` file
2. **Review task documentation**: Check \`requirements.md\` and \`implementation.md\`
3. **Review code changes**: Check changed files listed in drafts
4. **Improve drafts**: 
   - Add context from code
   - Improve wording and structure
   - Add code examples if relevant
   - Ensure consistency with existing docs
5. **Verify**: Check that drafts align with actual implementation

### Integration

After improving drafts, integrate them:

\`\`\`bash
# Review drafts first, then integrate
npx contextor ${taskNumber} --integrate
\`\`\`

Or manually copy improved content from drafts to target files in \`.ai/\` directory.

## ðŸ“ Target Documentation Files

${targetsList}

## âœ… Checklist

- [ ] Drafts reviewed
- [ ] Content improved and refined
- [ ] Code examples added (if relevant)
- [ ] Consistency checked with existing docs
- [ ] Ready for integration

---
*This file is auto-generated. Drafts are gitignored and temporary.*
`;
  }

  /**
   * Extract detailed content from task info
   */
  extractDetailedContent(taskInfo) {
    let content = '';

    if (taskInfo.implementation) {
      // Try to extract implementation details
      const approachMatch = taskInfo.implementation.match(/## Approach\s*\n\n(.+?)(?=\n##|$)/s);
      const stepsMatch = taskInfo.implementation.match(/## Implementation Steps\s*\n\n(.+?)(?=\n##|$)/s);
      
      if (approachMatch) {
        content += `### Approach\n\n${approachMatch[1].trim()}\n\n`;
      }
      if (stepsMatch) {
        content += `### Implementation Steps\n\n${stepsMatch[1].trim()}\n\n`;
      }
    }

    if (taskInfo.requirements) {
      const funcReqMatch = taskInfo.requirements.match(/## Functional Requirements\s*\n\n(.+?)(?=\n##|$)/s);
      if (funcReqMatch) {
        content += `### Requirements\n\n${funcReqMatch[1].trim()}\n\n`;
      }
    }

    if (!content) {
      content = 'See task documentation files for details.';
    }

    return content;
  }

  /**
   * Read task information from task directory
   */
  readTaskInfo(taskDir) {
    const readmePath = path.join(taskDir, 'README.md');
    const requirementsPath = path.join(taskDir, 'requirements.md');
    const implementationPath = path.join(taskDir, 'implementation.md');

    if (!fs.existsSync(readmePath)) {
      return null;
    }

    const readme = fs.readFileSync(readmePath, 'utf8');
    const requirements = fs.existsSync(requirementsPath) 
      ? fs.readFileSync(requirementsPath, 'utf8')
      : '';
    const implementation = fs.existsSync(implementationPath)
      ? fs.readFileSync(implementationPath, 'utf8')
      : '';

    // Extract task description from README
    const titleMatch = readme.match(/^# Task \d+: (.+)$/m);
    const description = titleMatch ? titleMatch[1] : 'Untitled Task';

    // Extract status
    const statusMatch = readme.match(/\*\*Status\*\*:\s*(.+)/);
    const status = statusMatch ? statusMatch[1].trim() : 'ðŸš§ In Progress';

    return {
      dir: taskDir,
      description,
      status,
      readme,
      requirements,
      implementation
    };
  }

  /**
   * Get changed files related to task (using git diff)
   */
  getChangedFiles(taskDir) {
    try {
      // Get files changed since last commit or in working directory
      const gitStatus = execSync('git status --porcelain', {
        cwd: this.projectRoot,
        stdio: ['ignore', 'pipe', 'ignore']
      }).toString().trim();

      const changedFiles = gitStatus
        .split('\n')
        .filter(line => line.trim())
        .map(line => {
          const status = line.substring(0, 2).trim();
          const file = line.substring(3);
          return { status, file: path.join(this.projectRoot, file) };
        })
        .filter(item => {
          // Filter source files (not docs, not in .ai/dev)
          const relativePath = path.relative(this.projectRoot, item.file);
          return !relativePath.startsWith('.ai') && 
                 !relativePath.startsWith('node_modules') &&
                 (relativePath.endsWith('.js') || 
                  relativePath.endsWith('.ts') || 
                  relativePath.endsWith('.jsx') || 
                  relativePath.endsWith('.tsx') ||
                  relativePath.endsWith('.py') ||
                  relativePath.endsWith('.java'));
        });

      return changedFiles;
    } catch (error) {
      // Git not available or not a git repo
      return [];
    }
  }

  /**
   * Update documentation based on task info and changed files
   */
  async updateDocumentation(taskInfo, changedFiles) {
    const updated = [];
    const created = [];

    // Determine which documentation files to update/create
    const docTargets = this.determineDocTargets(taskInfo, changedFiles);

    for (const target of docTargets) {
      const docPath = path.join(this.docsDir, target.path);
      const exists = fs.existsSync(docPath);

      if (exists) {
        // Update existing documentation
        const updatedContent = this.updateDocContent(docPath, taskInfo, target);
        fs.writeFileSync(docPath, updatedContent, 'utf8');
        updated.push(docPath);
      } else {
        // Create new documentation
        const dir = path.dirname(docPath);
        if (!fs.existsSync(dir)) {
          fs.mkdirSync(dir, { recursive: true });
        }
        const newContent = this.createDocContent(target, taskInfo);
        fs.writeFileSync(docPath, newContent, 'utf8');
        created.push(docPath);
      }
    }

    return { updated, created };
  }

  /**
   * Determine which documentation files should be updated/created
   */
  determineDocTargets(taskInfo, changedFiles) {
    const targets = [];

    // Analyze task description and requirements to determine doc targets
    const description = taskInfo.description.toLowerCase();
    const requirements = taskInfo.requirements.toLowerCase();

    // Architecture changes
    if (description.includes('architecture') || 
        description.includes('structure') ||
        requirements.includes('architecture')) {
      targets.push({ path: 'architecture/system-overview.md', type: 'architecture' });
    }

    // API changes
    if (description.includes('api') || 
        description.includes('endpoint') ||
        requirements.includes('api')) {
      targets.push({ path: 'api/api-integration.md', type: 'api' });
    }

    // Component changes (frontend)
    if (description.includes('component') || 
        description.includes('ui') ||
        requirements.includes('component')) {
      targets.push({ path: 'components/component-guidelines.md', type: 'component' });
    }

    // Database changes
    if (description.includes('database') || 
        description.includes('schema') ||
        description.includes('migration')) {
      targets.push({ path: 'database/database-schema.md', type: 'database' });
    }

    // Default: update system overview if no specific target
    if (targets.length === 0) {
      targets.push({ path: 'architecture/system-overview.md', type: 'architecture' });
    }

    return targets;
  }

  /**
   * Update existing documentation content
   */
  updateDocContent(docPath, taskInfo, target) {
    const existing = fs.readFileSync(docPath, 'utf8');
    const date = new Date().toISOString().split('T')[0];

    // Extract task summary from implementation or requirements
    const taskSummary = this.extractTaskSummary(taskInfo);

    // Add task information section if not exists
    if (!existing.includes('## Recent Changes') && !existing.includes('## Task Updates')) {
      const insertPoint = existing.indexOf('## ðŸ”— Related Documentation');
      if (insertPoint > 0) {
        const before = existing.substring(0, insertPoint);
        const after = existing.substring(insertPoint);
        return `${before}\n## Recent Changes

**Last Updated**: ${date}

### Task: ${taskInfo.description}

${taskSummary}

${after}`;
      }
    }

    // Update Last Updated date
    const updated = existing.replace(
      /\*\*Last Updated\*\*:\s*\d{4}-\d{2}-\d{2}/,
      `**Last Updated**: ${date}`
    );

    return updated;
  }

  /**
   * Create new documentation content
   */
  createDocContent(target, taskInfo) {
    const date = new Date().toISOString().split('T')[0];
    const taskSummary = this.extractTaskSummary(taskInfo);

    return `# ${this.getDocTitle(target.type)}

**Last Updated**: ${date}
**Version**: 1.0.0

## Overview

${this.getDocOverview(target.type)}

## Recent Changes

### Task: ${taskInfo.description}

${taskSummary}

## Details

Add detailed documentation here.

## ðŸ”— Related Documentation
`;
  }

  /**
   * Extract task summary from task info
   */
  extractTaskSummary(taskInfo) {
    // Try to extract from implementation first, then requirements
    let summary = '';
    
    if (taskInfo.implementation) {
      const overviewMatch = taskInfo.implementation.match(/## Approach\s*\n\n(.+?)(?=\n##|\n\*\*|$)/s);
      if (overviewMatch) {
        summary = overviewMatch[1].trim();
      }
    }

    if (!summary && taskInfo.requirements) {
      const overviewMatch = taskInfo.requirements.match(/## Overview\s*\n\n(.+?)(?=\n##|\n\*\*|$)/s);
      if (overviewMatch) {
        summary = overviewMatch[1].trim();
      }
    }

    if (!summary) {
      summary = `Implementation details from task ${path.basename(taskInfo.dir)}.`;
    }

    return summary;
  }

  /**
   * Get documentation title based on type
   */
  getDocTitle(type) {
    const titles = {
      'architecture': 'System Architecture',
      'api': 'API Integration',
      'component': 'Component Guidelines',
      'database': 'Database Schema'
    };
    return titles[type] || 'Documentation';
  }

  /**
   * Get documentation overview based on type
   */
  getDocOverview(type) {
    const overviews = {
      'architecture': 'System architecture and design decisions.',
      'api': 'API integration patterns and endpoints.',
      'component': 'Component patterns and guidelines.',
      'database': 'Database schema and design.'
    };
    return overviews[type] || 'Project documentation.';
  }
}

module.exports = { TaskIntegrator };

